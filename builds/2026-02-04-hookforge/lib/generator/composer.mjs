// Pattern Composer — Merges multiple hook patterns into a single contract

import patternRegistry from '../patterns/index.mjs';

export async function composePatterns(patternIds, params) {
  const patterns = [];
  const warnings = [];

  // Load all patterns
  for (const id of patternIds) {
    const pattern = await patternRegistry.getPattern(id);
    if (!pattern) {
      throw new Error(`Pattern not found: ${id}`);
    }
    patterns.push(pattern);
  }

  // Check for callback conflicts
  const callbackMap = new Map();
  for (const pattern of patterns) {
    for (const callback of pattern.callbacks) {
      if (callbackMap.has(callback)) {
        warnings.push({
          type: 'callback_conflict',
          message: `Both "${callbackMap.get(callback).name}" and "${pattern.name}" use ${callback}`,
          detail: 'Callback logic will be merged — review carefully for ordering issues',
          severity: 'warning'
        });
      }
      callbackMap.set(callback, pattern);
    }
  }

  // Merge flags
  const allFlags = new Set();
  for (const p of patterns) {
    for (const f of p.flags) allFlags.add(f);
  }

  // Merge gas estimates
  const totalGas = {};
  for (const p of patterns) {
    for (const [cb, gas] of Object.entries(p.gasEstimate)) {
      totalGas[cb] = (totalGas[cb] || 0) + gas;
    }
  }

  // Generate composed Solidity
  const solidity = generateComposedSolidity(patterns, allFlags, params);
  const test = generateComposedTest(patterns, params);

  // Collect all pitfalls
  const allPitfalls = patterns.flatMap(p => 
    p.pitfalls.map(pit => ({ type: 'pitfall', message: `[${p.name}] ${pit}`, severity: 'info' }))
  );

  return {
    patterns: patternIds,
    solidity,
    test,
    warnings: [...warnings, ...allPitfalls],
    gasEstimate: totalGas,
    metadata: {
      name: patterns.map(p => p.name).join(' + '),
      callbacks: [...callbackMap.keys()],
      flags: [...allFlags],
      complexity: Math.max(...patterns.map(p => p.complexity)) + 1
    }
  };
}

function generateComposedSolidity(patterns, flags, params) {
  const contractName = 'ComposedHook';
  
  // Collect all unique imports
  const imports = new Set([
    'import {BaseHook} from "v4-periphery/src/base/hooks/BaseHook.sol";',
    'import {Hooks} from "v4-core/src/libraries/Hooks.sol";',
    'import {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";',
    'import {PoolKey} from "v4-core/src/types/PoolKey.sol";',
    'import {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";',
    'import {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";',
    'import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";',
    'import {Currency, CurrencyLibrary} from "v4-core/src/types/Currency.sol";',
    'import {SafeCast} from "v4-core/src/libraries/SafeCast.sol";'
  ]);

  // Determine which callbacks are used
  const callbackSet = new Set();
  for (const p of patterns) {
    for (const cb of p.callbacks) callbackSet.add(cb);
  }

  // Build flag permissions
  const flagStr = (flag) => flags.has(flag) ? 'true' : 'false';

  return `// SPDX-License-Identifier: MIT
// Generated by HookForge — Composed from: ${patterns.map(p => p.name).join(', ')}
pragma solidity ^0.8.26;

${[...imports].join('\n')}

/// @title ${contractName}
/// @notice Composed hook combining: ${patterns.map(p => p.name).join(', ')}
/// @dev Generated by HookForge (github.com/0xAxiom/daily-builds)
contract ${contractName} is BaseHook {
    using PoolIdLibrary for PoolKey;
    using BeforeSwapDeltaLibrary for BeforeSwapDelta;
    using SafeCast for uint256;
    using SafeCast for int256;
    using CurrencyLibrary for Currency;

    // === State Variables ===
    // Add your state variables here based on composed pattern needs
    
    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {
        // Initialize composed hook state
    }

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
            beforeInitialize: ${flagStr('beforeInitialize')},
            afterInitialize: ${flagStr('afterInitialize')},
            beforeAddLiquidity: ${flagStr('beforeAddLiquidity')},
            afterAddLiquidity: ${flagStr('afterAddLiquidity')},
            beforeRemoveLiquidity: ${flagStr('beforeRemoveLiquidity')},
            afterRemoveLiquidity: ${flagStr('afterRemoveLiquidity')},
            beforeSwap: ${flagStr('beforeSwap')},
            afterSwap: ${flagStr('afterSwap')},
            beforeDonate: ${flagStr('beforeDonate')},
            afterDonate: ${flagStr('afterDonate')},
            beforeSwapReturnDelta: ${flagStr('beforeSwapReturnDelta')},
            afterSwapReturnDelta: ${flagStr('afterSwapReturnDelta')},
            afterAddLiquidityReturnDelta: ${flagStr('afterAddLiquidityReturnDelta')},
            afterRemoveLiquidityReturnDelta: ${flagStr('afterRemoveLiquidityReturnDelta')}
        });
    }

${callbackSet.has('beforeSwap') ? `    function beforeSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        bytes calldata hookData
    ) external override returns (bytes4, BeforeSwapDelta, uint24) {
        // === Composed beforeSwap logic ===
        // Patterns: ${patterns.filter(p => p.callbacks.includes('beforeSwap')).map(p => p.name).join(', ')}
        
        // V4 Convention: amountSpecified < 0 = exact-input
        bool exactInput = params.amountSpecified < 0;
        uint256 amountIn = exactInput 
            ? uint256(-params.amountSpecified) 
            : uint256(params.amountSpecified);

        // TODO: Implement composed logic from individual patterns
        // Each pattern's beforeSwap logic should be merged here
        // Be careful about delta accumulation when combining fee-taking patterns

        return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);
    }
` : ''}${callbackSet.has('afterSwap') ? `    function afterSwap(
        address sender,
        PoolKey calldata key,
        IPoolManager.SwapParams calldata params,
        BalanceDelta delta,
        bytes calldata hookData
    ) external override returns (bytes4, int128) {
        // === Composed afterSwap logic ===
        // Patterns: ${patterns.filter(p => p.callbacks.includes('afterSwap')).map(p => p.name).join(', ')}

        // TODO: Implement composed logic from individual patterns

        return (BaseHook.afterSwap.selector, 0);
    }
` : ''}${callbackSet.has('beforeAddLiquidity') ? `    function beforeAddLiquidity(
        address sender,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata params,
        bytes calldata hookData
    ) external override returns (bytes4) {
        // === Composed beforeAddLiquidity logic ===
        return BaseHook.beforeAddLiquidity.selector;
    }
` : ''}${callbackSet.has('afterAddLiquidity') ? `    function afterAddLiquidity(
        address sender,
        PoolKey calldata key,
        IPoolManager.ModifyLiquidityParams calldata params,
        BalanceDelta delta,
        BalanceDelta feesAccrued,
        bytes calldata hookData
    ) external override returns (bytes4, BalanceDelta) {
        // === Composed afterAddLiquidity logic ===
        return (BaseHook.afterAddLiquidity.selector, delta);
    }
` : ''}}`;
}

function generateComposedTest(patterns, params) {
  return `// SPDX-License-Identifier: MIT
// Generated by HookForge — Test suite for composed hook
pragma solidity ^0.8.26;

import "forge-std/Test.sol";
import "../src/ComposedHook.sol";

contract ComposedHookTest is Test {
    ComposedHook hook;

    function setUp() public {
        // Deploy composed hook
    }

${patterns.map(p => `    function test${p.name.replace(/\s+/g, '')}Behavior() public {
        // Test ${p.name} behavior within composed hook
    }
`).join('\n')}
    function testComposedInteraction() public {
        // Test that composed patterns work correctly together
    }
}`;
}
